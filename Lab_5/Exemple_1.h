/*

Разберите программу.

*/

#include <iostream>
#include <string>
using namespace std;

class Complex {
    friend Complex operator+(const Complex&, const Complex&);
    friend Complex operator+(const Complex&, const int&);

private:
    int r, ar[10]; // x = Re + Im*i 
public:


    Complex(int nr, int arr[10]) {
        r = nr;
        for (int i = 0; i < 10; i++) {
            ar[i] = arr[i];
        }
    }

    Complex operator+= (const Complex& c);

    Complex operator+(const Complex& c) {             // 1.1 через метод класса
        int r = this->r + c.r;
        int m[10];
        for (int i = 0; i < 10; i++) {
            m[i] = ar[i] + c.ar[i];
        }
        return Complex(r, m);
    }

    void print() {
        cout << r;
        for (int i = 0; i < 10; i++)
            cout << ar[i] << "*i" << i + 1 << endl;
    }

    friend ostream& operator << (ostream& os, const Complex& c);

    int operator[](int i);                          //1.3
};


ostream& operator << (ostream& os, const Complex& c) {
    string str = "";
    for (int i = 0; i < 10; i++) {
        str += " + " + to_string(c.ar[i]) + "*i" + to_string(i + 1);
    }

    os << c.r << str << endl;
    return os;
}

Complex operator+ (const Complex& c1, const Complex& c2) {               // 1.1 через дружественную функцию

    int r = c1.r + c2.r;
    int m[10];
    for (int i = 0; i < 10; i++) {
        m[i] = c1.ar[i] + c2.ar[i];
    }
    return Complex(r, m);
}

Complex operator+ (const Complex& c1, const int& c2) {                    //1.2
    double r = c1.r + c2;
    int m[10];
    for (int i = 0; i < 10; i++) {
        m[i] = c1.ar[i];
    }
    return Complex(r, m);
}

int Complex::operator[](int i) {                                        //1.3
    int x[2][10] = { 0 };
    x[0][0] = r;
    for (int i = 0; i < 10; i++) {
        x[1][i] = ar[i];
    }
    if (i == 0) return x[0][0];
    else if (i == 1) {
        int n;
        cout << "При каком значении i вывести коэффицент?" << endl;
        cin >> n;
        cout << "При i" + to_string(n)+" k = ";
        return x[1][n - 1];
    }
}

int Exemple_1() {
    setlocale(LC_ALL, "Rus");

    int arr1[10] = { 1, 2, 3, 4, 5};
    int arr2[10] = { 1, 2, 3, 4, 5};
    Complex a(0, arr1), b(2, arr2);

    Complex r1 = a + b;

    cout << "a - " << a;
    cout << "b - " << b << endl;

    cout <<"a+b - " << r1;

    cout << r1[1];
    return 0;
}

/*
Почти любой существующий оператор в языке C++ может быть перегружен.
(исключением являются: "?:", ".", "::", ".*")
Есть три разных способа перегрузки операторов: через дружественные функции, через обычные функции и через методы класса.

+ Упражнение 1.1.
Определите каким образом перегружен оператор operator+. Измените программу выполнив перегрузку этого оператора двумя другими спомобами.
Обратите внимание на особенности каждого из вариантов.

+ Упражнение 1.2.
Один оператор может работать с операндами разных типов.
Например, мы можем добавить Complex(5, 2) к числу 5 для получения результата Complex(10, 2).
Когда C++ обрабатывает выражение a + b, то a становится первым параметром, а b — вторым параметром. Если a и b одного и того же типа,
то не имеет значения, пишете ли вы a + b или b + a — в любом случае вызывается одна и та же версия operator+().
Однако, если операнды разных типов, то a + b — это уже не то же самое, что b + a.
Добавьте перегрузку оператора "+" для сложения переменных Complex с int.

+ Упражнение 1.3.
Не всё может быть перегружено через дружественные функции, Операторы присваивания (=), индекса ([]), вызова функции (()) и выбора члена (->)
перегружаются через методы класса — это требование языка C++.
Перегрузите оператор индексации  "[]" для класса Complex, подразумевая вещественную часть под индексом 0, а мнимую под - 1.
Для этого добавьте в класс объявление соответствующей функции и дополните её описание:

int& Complex::operator[] (int index){
    ...
}

Обратите внимание, если указать параметр по умолчанию для функции перегрузки оператора [], и не укажем внутри скобок значение индекса, то получим ошибку.

Почему оператор индексации [] использует возврат по ссылке?

Упражнение 1.4.
Измените класс таким образом чтобы он описывал гиперкомплексные числа (числа обладающие векторной комплексной частью с некомутирующими множителями i1, i2, i3).
Например, с 10 такими множителями. То есть:

private:
    double r, m[10];

Адаптируйте все разработанные функции под этот случай.

Упражнение 1.5.
Если попытаться вызвать operator[]() для указателя на объект, то это будет расценено как индексация массива.
Например:

    Complex *a = new Complex;
    a[4] = 5; // ошибка !!!
    delete a;

Это происходит из-за того, что указатель указывает на адрес памяти, а не на значение.
Поэтому сначала указатель нужно разыменовать, а затем уже использовать оператор [].
Исправьте приведённую выше ошибку.

Упражнение 1.6.
Не всё может быть перегружено через методы класса.
Например перегрузка операторов ввода и вывода имеет ряд особенностей. Эти особенности связаны с типом операндов скоторыми работает этот оператор.
Чем для оператора << являются операнды?

(std::cout - это объект std::ostream)

Перегрузите оператор вывода << и ввода >> для класса Complex как дружественные функции.

Реализация перегрузки оператора << для нашего класса Complex проста, так как C++ уже знает,
как выводить значения типа int, а все атрибуты имеют этот тип,
поэтому можно просто использовать оператор << для вывода переменных-членов.

Также можно перегрузить и оператор ввода. Главное помнить, что std::cin является объектом типа std::istream.

*/



